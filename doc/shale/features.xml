<?xml version="1.0"?>
<document url="index.html">

  <properties>
    <title>Shale Framework Features</title>
  </properties>

  <body>


    <section name="Shale View Controller" href="view">


      <subsection name="Introduction"   href="view-introduction">

        <p>Shale supports a mechanism that provides a 1:1 relationship between
        a view tier presentation technology, which is responsible for creating
        an HTTP response (such as a JSP page), and a corresponding JavaBean class
        containing event handling logic, (optionally) values used in the dynamic
        rendering of the response, and (optionally) bindings to the individual
        user interface components included in the response page.  Such a JavaBean
        class is known (in JavaServer Faces terminology) as a <em>backing bean</em>.
        In most circumstances, such a bean will be registered as a managed bean
        (configured for creation in request scope).</p>

        <p>JavaServer Faces does not require that a backing bean implement any
        particular interface, or extend any particular base class.  Therefore,
        Shale does not impose any such restriction either.  Instead, it promises
        that <em>if</em> an application's backing bean implements the
        <code>ViewController</code> interface, then certain extra services will
        be provided "for free."</p>

      </subsection>


      <subsection name="Provided Services" href="view-services">

        <p>Each backing bean that implements <code>ViewController</code> will
        support a boolean property <code>postback</code>, which will be set to
        <code>true</code> if this view is the one that is processing a form
        submit previously rendered by the same page, or <code>false</code> if
        this view was newly navigated to.  The property will be set before any
        of the lifecycle methods described below are called, so that application
        logic may perform conditional tasks based on this state.</p>
        
        <p>As part of the standard JavaServer Faces managed beans processing, any
        <code>&lt;managed-property&gt;</code> elements in the configuration
        file, that are nested inside the <code>&lt;managed-bean&gt;</code>
        element for this backing bean, will also be processed when a new bean
        instance is created.  You can use either literal values or value binding
        expressions to customize properties on your backing bean class.  Fans
        of <em>Dependency Injection</em> will see that the managed beans facility
        provides support for such a framework, using Setter Injection as the
        mechanism for injecting dependencies.</p>

        <p>In addition, the following lifecycle events are called, by the
        framework, at certain points in the JavaServer Faces request processing
        lifecycle:</p>

        <ul>
        <li><strong>init()</strong> - Called immediately after the view that
            this backing bean is associated with is created.  (Technically, it
            happens when <code>ViewManager.createView()</code> is called.)
            For a postback, this happens during the <em>Restore View</em>
            phase of the request processing lifecycle, once it ha been
            determined which view should be restored.  If your application
            navigates from one page to another, the <code>init()</code> method
            of the second page will be called as part of the
            <code>NavigationHandler.handleNavigation()</code> processing.
            <blockquote>
              Use this method to acquire resources that you will need, no
              matter whether this is a postback request, a rendering request,
              or both.
            </blockquote></li>
        <li><strong>preprocess()</strong> - Called after the <em>Restore View</em>
            phase has been completed, but before <em>Apply Request Values</em>
            phase starts, <strong>only</strong> for the view that will be
            processing the postback.
            <blockquote>
              Use this method to acquire resources (such as database connections)
              that you will need to process the postback.
            </blockquote></li>
        <li><strong>prerender()</strong> - Called immediately before the
            <em>Render Response</em> phase that actually causes the view to
            be rendered.  This method will <strong>only</strong> be called for
            the view that is actually rendered (the current view if you are
            redisplaying, or the new view if you perform navigation).
            <blockquote>
              Use this method to acquire resources (such as database connections,
              or performing queries) that you will need if this view is the one
              to be rendered.  NOTE - when portlet support is integrated, all of
              the portlets on the current page will receive this event.
            </blockquote></li>
        <li><strong>destroy()</strong> - If <code>init()</code> was ever called
            for a <code>ViewController</code>, then it is guaranteed that
            <code>destroy()</code> will be called as well.
            <blockquote>
              Use this method to release any resources acquired during an earlier
              event handler.
            </blockquote></li>
        </ul>

        <p>It can be difficult initially to visualize the order that events will
        occur, based solely on the descriptions above.  Let's look at some
        common scenarios and see what happens when:</p>
        
        <ul>
        <li><em>Initial navigation to welcome page, or a page directly accessed
            via a URL</em>:
            <ul>
            <li>Backing bean is instantiated during <em>Restore View</em> phase,
                which notices that there is no previous state to restore.</li>
            <li>The <code>setPostback(false)</code> and <code>init()</code> methods
                on your backing bean are called.</li>
            <li>Because there is no previous state to restore, there will be no
                form submit processing.</li>
            <li>The <code>prerender()</code> method is called.</li>
            <li>Standard <em>Render Response</em> phase processing occurs,
                which causes the view to be rendered.</li>
            <li>The <code>destroy()</code> method is called.</li>
            </ul></li>
        <li><em>Postback processed by a page that then redisplays itself (by
            returning <code>null</code> from the action handler.</em>:
            <ul>
            <li>Backing bean is instantiated during <em>Restore View</em> phase,
                which notices that there is previous state to restore.</li>
            <li>The <code>setPostback(true)</code> and <code>init()</code> methods
                on your backing bean are called.</li>
            <li>Standard <em>Apply Request Values</em> through <em>Invoke
                Application</em> phase processing occurs, which includes calling
                your action and value change event handlers.</li>
            <li>The <code>prerender()</code> method is called.</li>
            <li>Standard <em>Render Response</em> phase processing occurs,
                which causes the view to be rendered.</li>
            <li>The <code>destroy()</code> method is called.</li>
            </ul></li>
        <li><em>Postback processed by page A, which then navigates to page B</em>:
            <ul>
            <li>Backing bean for page A is instantiated during <em>Restore View</em>
                phase, which notices that there is previous state to restore.</li>
            <li>The <code>setPostback(true)</code> and <code>init()</code> methods
                on your backing bean for page A are called.</li>
            <li>Standard <em>Apply Request Values</em> through <em>Invoke
                Application</em> phase processing occurs for page A, which
                includes calling your action and value change event handlers.</li>
            <li>As part of the navigation process, the backing bean for
                page B is created.</li>
            <li>The <code>prerender()</code> method for page B is called.</li>
            <li>Standard <em>Render Response</em> phase processing occurs,
                which causes the view to be rendered.</li>
            <li>The <code>destroy()</code> method is called for both page B
                and page A (since two backing beans were instantiated).</li>
            </ul></li>
        </ul>

      </subsection>


      <subsection name="Using View Controller" href="view-using">

        <p>For each JavaServer Faces <em>view</em> that you wish to associate
        with a <code>ViewController</code> backing bean, you must:</p>

        <ul>
          <li>Implement the <code>ViewController</code> interface.  The
              most convenient way to do this is likely to be extending the
              convenience base class (<code>org.apache.shale.view.ViewController</code>).</li>
          <li>As required by the JavaBeans specification, provide a no-args
              public constructor.</li>
          <li>Declare your backing bean as a managed bean.  In nearly all
              circumstances, you will want the bean to be placed in
              request scope.</li>
          <li>(Optional) Provide public JavaBean properties that may be set
              to customize the functionality provided by this bean.  Typically,
              such properties will be configured based on the managed beans
              configuration defined in the JavaServer Faces configuration
              resources for your application.</li>
          <li>Ensure that the functionality of your backing bean is
              <strong>not</strong> dependent upon the order in which property
              setters are called, since managed beans are configured via
              the "setter injection" pattern.</li>
          <li>Create event handlers for the lifecycle events of interest,
              plus standard JavaServer Faces event handlers for things like
              actions and value changes.</li>
          <li>(Optional but recommended) write a corresponding JUnit test
              case using the Shale <a href="features.html#test">Test Framework</a>.
              Because nearly all of your property and event handling methods
              have no JavaServer Faces API dependencies for their parameter
              signatures, it is generally quite easy to write such tests.</li>
        </ul>

      </subsection>


    </section>


    <section name="Shale Dialog Manager" href="dialog">


      <subsection name="Introduction"   href="dialog-introduction">

        <p>One of the frustrating aspects of organizing the flow of control
        in a web based application is that fact that it is composed of
        completely disconnected interactions with the client (via the
        HTTP protocol).  The popularity of application frameworks based
        on model-view-controller (MVC) principles, and particularly the
        emergence of the <em>front controller</em> design pattern, have
        become the de facto standard architectural approach.</p>

        <p>Like other frameworks, JavaServer Faces supports a mechanism
        to define navigation rules for transitions between views.  The
        actual processing is performed by an implementation of
        the <code>javax.faces.application.NavigationHandler</code>.  The
        standard implementation provided by the framework (which can be
        customized via a pluggable API) performs transitions from one view
        to another based on three inputs:</p>

        <ul>
        <li>What view is currently processing this form submit?</li>
        <li>Which of the potentially several actions were invoked?  (This
            allows you to support different "submit" buttons with different
            functionality, or share actions between, say, a "Save" button
            at the top and bottom of a table.)</li>
        <li>What "logical outcome" was returned by the action that was
            invoked?</li>
        </ul>

        <p>Basing navigation on outcomes, by the way, assists in reducing
        the coupling between pages, because the developer that writes the
        action method is only focused on reporting "what happened" rather
        than worrying about "where do I go next".  This concept is also
        found in the way Struts has <code>Action.execute()</code> methods
        that return a logical <code>ActionForward</code> describing the
        outcome of performing the action.</p>

        <p>However, it is still difficult to reuse individual views in
        more than one "conversation" or "dialog" with the user, nor to
        treat one dialog as a "black box" subroutine that can be called by
        more than one calling dialog.  To address these needs, Shale
        offers Dialog Manager support.</p>

        <p>The functionality of this feature was <strong>heavily</strong>
        inspired by the implementation of Spring Webflow (Preview 2),
        whose home page is:</p>
        <blockquote>
        <a href="http://opensource.atlassian.com/confluence/spring/display/WEBFLOW/Home">
        http://opensource.atlassian.com/confluence/spring/display/WEBFLOW/Home</a>
        </blockquote>

      </subsection>


      <subsection name="Services Provided" href="dialog-services">

        <p>Conceptually, a <em>dialog</em> can be thought of as a set of labelled
        states, connected by labelled transitions between those states.  Indeed,
        a UML <em>State Diagram</em> is a popular way to represent the
        architecture of such a dialog.  Each dialog has a specified starting
        state (with an automatic transition to this state when the dialog is
        first started), and one or more ending states.</p>

        <p>Shale supports four state types, with specific implementations
        realized as described below.</p>

        <ul>
        <li><em>ActionState</em> - Represents a call to a public method, taking
            no parameters, and returning a String that will be treated as the
            logical outcome.  The method to be called is configured with a
            JavaServer Faces <em>method binding expression</em>, which means
            you can leverage the managed beans facility to instantiate your
            processing classes on demand.  The logical outcome is used to
            drive the transition to the next state, as described below.</li>
        <li><em>ViewState</em> - Represents the rendering of a JavaServer Faces
            <em>view</em>, followed by a wait for the subsequent form submit.
            The logical outcome returned by the action method (typically on
            the <code>ViewController</code> bean that you've associated with
            the current page) is used to drive the transition to the next
            state, as described below.</li>
        <li><em>SubdialogState</em> - Represents pushing the state of the
            current dialog onto a stack, and starting a specified new dialog
            at its starting state.  When the subordinate dialog returns, the
            calling dialog is resumed, with the logical outcome returned by
            the subordinate dialog is used to drive the transition to the next
            state, as described below.</li>
        <li><em>EndState</em> - Terminates the current dialog (popping the
            stack if we are inside a subdialog), and returns a logical outcome
            (to drive transition) in one of two ways:
            <ul>
            <li>If a view identifier was configured, cause that view to be
                rendered and return the logical outcome from the application
                action that is invoked (just like a ViewState, but also
                terminates the dialog).</li>
            <li>If no view identifier was configured (meaning that the parent
                dialog will be responsible for rendering the response to the
                current request), simply return the logical outcome that
                caused this EndState to be selected.</li>
            </ul></li>
        </ul>

        <p>Transitions between states are performed by consulting the set of
        <em>Transition</em>s that have been defined (either locally for this
        State, or globally for the entire Dialog), matching on logical outcome.
        The matching Transition is then used to select the identifier of the
        next state to be performed (which can be of any type).</p>

        <p>It is <strong>not</strong> required that all JavaServer Faces
        interactions be organized into dialogs -- you can have a mix of
        dialog and standard navigation processing.  Indeed, to enter a
        dialog in the first place, simply have one of your standard action
        methods return a logical outcome of <strong>dialog:xxxxx</strong>,
        which will cause the dialog named <code>xxxxx</code> to be entered
        at its starting state.  Once that dialog completes, standard
        JavaServer Navigation will resume.</p>

        <p>The configuration of a Dialog is represented as a tree of
        JavaBeans defined in the <code>org.apache.shale.dialog</code>code>
        package, rooted at an instance <code>Dialog</code>.  The set of
        all known <code>Dialog</code> instances is stored in a <code>Map</code>,
        keyed by dialog identifier, which is stored in an application scope
        attribute named by symbolic constant <code>Globals.DIALOGS</code>.
        The <code>Dialog</code> instances may be configured by any desired
        mechanism; however, the most commonly used will likely be an XML
        document that conforms to a DTD provided by Shale.</p>

      </subsection>


      <subsection name="Using Dialog Manager" href="dialog-using">

        <p>To use the Dialog Manager facilities in Shale, take the following
        steps:</p>

        <ul>
        <li>Model your dialog as a series of <em>State</em>s with transitions
            between them labelled with the logical outcome that selects
            that particular transition.  A UML State Diagram is a very useful
            mechanism for visualizing such a model.</li>
        <li>Build the views (and corresponding <code>ViewController</code> beans)
            that comprise your dialog, using standard JavaServer Faces and
            (optional) Shale <code>ViewController</code> facilities.</li>
        <li>Define your dialogs in an XML document, conventionally named
            <code>/WEB-INF/dialog-config.xml</code>, that conforms to the
            required DTD, which defines all the state transitions:
            <blockquote><pre>
&lt;!DOCTYPE dialogs PUBLIC
  "-//Apache Software Foundation//DTD Shale Dialog Configuration 1.0//EN"
  "http://struts.apache.org/dtds/shale-dialog-config-1_0.dtd">

&lt;dialogs>

  &lt;dialog name="First Dialog Name" start="Start State Id">
    ... &lt;action/>, &lt;view/>, &lt;subdialog/>, and &lt;exit/> elements for states ...
  &lt;/dialog>

  &lt;dialog name="Second Dialog Name" start="Start State Id">
    ... &lt;action/>, &lt;view/>, &lt;subdialog/>, and &lt;exit/> elements for states ...
  &lt;/dialog>

  ...

&lt;/dialogs>
</pre></blockquote></li>
        <li>If you have more than one dialog configuration file, or you have
            defined your only dialog configuration file as a web application
            resource with a name different than the one described above, use
            a context initiaization parameter to define a comma-delimited list
            of context-relative paths to configuration resources to be loaded:
            <blockquote><pre>
&lt;context-param>
  &lt;param-name>org.apache.shale.dialog.CONFIGURATION&lt;/param-name>
  &lt;param-value>/WEB-INF/foo.xml,/WEB-INF/bar.xml&lt;/param-value>
&lt;/context-param>
</pre></blockquote></li>
        <li>In addition to the dialog configuration resources defined by this
            context initialization parameter, a resource named
            <code>/WEB-INF/dialog-config.xml</code> will be automatically
            processed, if it exists.</li>
<!--
        <li>Alternatively, or in addition to the above, any JAR file in
            <code>/WEB-INF/lib</code> will be scanned for configuration
            documents at <code>META-INF/dialog-config.xml</code>.  Such
            resources will be automatically processed, making it easy to
            define JAR files with dialog configurations and corresponding
            Java classes and resources, which are recognized simply by
            including this JAR file in the application.</li>
-->
        <li>To initiate a dialog named "xxxxx", configure one of your standard
            JavaServer Faces actions to return a logical outcome of
            <code>dialog:xxxxx</code></li>
        </ul>

      </subsection>


    </section>


    <section name="Shale Application Manager" href="application">

      <p>FIXME - Describe application manager feature.</p>

    </section>


    <section name="Shale Validation"          href="validation">

      <p>FIXME - Describe validation feature.</p>

    </section>


    <section name="Shale Remoting"            href="remoting">

      <p>FIXME - Describe remoting feature.</p>

    </section>


    <section name="Shale Spring Integration"  href="spring">

      <p>FIXME - Describe Spring integration feature.</p>

    </section>


    <section name="Shale Reusable Views"      href="clay">

      <p>FIXME - Describe Clay plugin feature.</p>

    </section>


    <section name="Shale Test Framework"      href="test">

      <p>FIXME - Describe Test Framework feature.</p>

    </section>


  </body>

</document>
